#!/usr/bin/env python3
import sys
import re
import random
import time
class Client(process):

	def setup(bankname,reply_wait,num_retry,req_details,head,tail):
		self.client_id = self.id._address[1]
		output('client id:'+str(client_id))
	

	def main():
		#Generate requests based on probabilities and sent to servers
		output(req_details[0])
		if req_details[0] == 'random':
			seed,numreq,prob_bal,prob_dep,prob_withdraw = req_details[1:]
			weight = {}
			weight['getbalance'], weight['deposit'], weight['withdraw']  = int(prob_bal * 100), int(prob_dep * 100), int(prob_withdraw * 100)
			choice_list = [s for s in weight for i in range(weight[s])]
			random.seed(seed)
			for i in range(numreq):
				ops = random.choice(choice_list)
				seq_no = random.randint(10,100)
				account_no = random.randint(100000,999999)
				if ops == 'getbalance':
					amount = None
					server = tail
				else:
					server = head
					amount = random.randint(1,500)
				req_id = '.'.join((bankname,str(client_id),str(seq_no)))
				output('ops:'+ops+' account_no:'+str(account_no)+' req_id:'+req_id+' amount:'+str(amount))
				send((ops,[account_no,req_id,amount]), to=server)
		else:
			output(req_details)
			requests = req_details[1:]
			for req in requests:
				if len(req.strip().split(',')) == 3:
					ops,req_id,account_no = req.strip().split(',')
					amount = None
					server = tail
				else:
					ops,req_id,account_no,amount = req.strip().split(',')
					amount,account_no = int(amount),int(account_no)
					server = head
				output('ops:'+ops+' account_no:'+str(account_no)+' req_id:'+req_id+' amount:'+str(amount))
				send((ops,[account_no,req_id,amount]), to=server)
		output('******:'+str(listof(p,received(('Toclient',reply), from_=p))))
		await(False)
		#await((len(listof(p, received(('Toclient',reply), from_=p)))) == count)	
	def receive(msg=('Toclient',reply),from_=p):
		output('reply:'+str(reply))
		
	def getRandomOps():
		output('implement random ops')
			

class Server(process):
	
	def setup(bankname,startupdelay,serverlifetime,successor,predecessor):
		self.server_id = self.id._address[1]
		self.account_details = {}
	def main():
		output('serverlifetime:'+str(serverlifetime))
		if serverlifetime[0] == 'receive':
			count = int(serverlifetime[1])
			await((len(listof(p, received((ops,values), from_=p))) + len(listof(p, received(('FromServer',account_no,status,client), from_=p)))) == count)
		elif serverlifetime[0] == 'send':
			count = int(serverlifetime[1])
			await((len(listof(reply, sent(('Toclient',reply), to=p))) + len(listof(p, sent(('FromServer',account_no,status,p), to=p)))) == count)
		else:
			await(False)
		
	#Receive from client
	def receive(msg=(ops,values),from_=p):
		output('------>>>in first receive of server')
		account_no,req_id,amount = values
		if isAccountExists(account_no) is False:
			createAccount(account_no)
		if ops == 'getbalance':
			reply = getBalance(req_id,account_no)
			send(('Toclient',reply),to=p)
		elif ops == 'deposit':
			status = deposit(req_id,account_no,amount)
			output(status)
			if successor is None:
				send(('Toclient',status[1]),to=p)
			else:
				send(('FromServer',account_no,status,p),to=successor)
		elif ops == 'withdraw':
			status = withdraw(req_id,account_no,amount)
			output(status)
			if successor is None:
				send(('Toclient',status[1]),to=p)
			else:
				send(('FromServer',account_no,status,p),to=successor)
				
	#receive from another server
	def receive(msg=('FromServer',account_no,status,client),from_=s):
		output('*******>in second receive of server')
		if isAccountExists(account_no) is False:
			createAccount(account_no)
		output(status)
		if status[0] == 'valid':
			current_account = account_details[account_no]
			current_account.balance = status[2]
			current_account.processedTrans.append(status[3])
		#in case status not valid , just pass on to other servers
		if successor is None:
			send(('Toclient',status[1]),to=client)
		else:
			send(('FromServer',account_no,status,client),to=successor)

	def getBalance(req_id,account_no):
		if isAccountExists(account_no) is False:
			createAccount(account_no)
		reply = (req_id,account_no,'Processed',account_details[account_no].balance)
		return reply
		
	def deposit(req_id,account_no,amount):
		current_account = account_details[account_no]
		if verifyTransaction(req_id,'D',account_no,amount) == 1:
			current_account.balance	+= amount
			current_account.processedTrans.append((req_id,'D',amount))
			status =  ('valid',(req_id,account_no,'Processed',current_account.balance),current_account.balance,(req_id,'D',amount))
		elif verifyTransaction(req_id,'D',account_no,amount) == -1:
			status =  ('invalid',(req_id,account_no,'InconsistenWithHistory',current_account.balance))
		else:
			status = ('duplicate',(req_id,account_no,'Processed',current_account.balance))

		return status
	def withdraw(req_id,account_no,amount):
		current_account = account_details[account_no]
		if verifyTransaction(req_id,'W',account_no,amount) == 1:
			if current_account.balance < amount:
				status = ('invalid',(req_id,account_no,'InsufficientFunds',current_account.balance),current_account.balance)
			else:
                        	current_account.balance -= amount
                        	current_account.processedTrans.append((req_id,'W',amount))
                        	status =  ('valid',(req_id,account_no,'Processed',current_account.balance),current_account.balance,(req_id,'W',amount))
		elif verifyTransaction(req_id,'W',account_no,amount) == -1:
			status =  ('invalid',(req_id,account_no,'InconsistenWithHistory',current_account.balance))
		else:
                        status = ('duplicate',(req_id,account_no,'Processed',current_account.balance))
		return status
	
	def verifyTransaction(req_id,ops,account_no,amount):
		if account_no in account_details:
			if (req_id,ops,amount) in account_details[account_no].processedTrans:
				return 0
			elif req_id in [account_details[account_no].processedTrans[i][0] for i,j in enumerate(account_details[account_no].processedTrans)]:		
				return -1
			else:
				return 1
				
		
	def isAccountExists(account_no):
		if account_no in account_details:
			return True
		return False
			
	def createAccount(account_no):
		account_details[account_no] = Account(0,[])
class Account:
	def __init__(self,balance,processedTrans=[]):
		self.balance = balance
		self.processedTrans = processedTrans

	def displayAccountDetails(self):
		print('balance:',str(self.balance))

class Client_Details:

	def __init__(self,bankname,reply_wait,num_retry,request_details):
		self.bankname = bankname
		self.reply_wait = reply_wait
		self.num_retry = num_retry
		self.request_details = request_details

	def displayClientDetails(self):
		print("--Client details--\n")
		print("bankname:",self.bankname)
		print("reply_wait:",self.reply_wait)
		print("num_retry:",self.num_retry)
		print("request_detaisl",self.request.details)

class Server_Details:

	def __init__(self,startupdelay,serverlifetime):
		self.startupdelay = startupdelay
		self.serverlifetime = serverlifetime

	def displayServerDetails(self):
		print("--Server details--\n")
		print("startupdelay:",self.startupdelay)
		print("serverlifetime:",self.serverlifetime)

class Bank_Details:
	def __init__(self,bankname,chainlen,no_clients,client,server):
		self.bankname = bankname
		self.chainlen = chainlen
		self.no_clients = no_clients
		self.client = client
		self.server = server

	def displayBankDetails(self):
		print("Bankname:",self.bankname)
		print("chainlen:",self.chainlen)
		print("no_clients:",self.no_clients)
		self.client.displayClientDetails()
		self.server.displayServerDetails()
		
def main():
	
	config_file = '/Users/NafeesAhmed/Documents/async_project/chainreplication/config/test1_config.txt'
	bank_list = []
	f = open(config_file)
	lines = f.readlines()
	for line in lines:
			if len(line.strip()) == 0 or line.startswith('#') or line.startswith('<Bank-Start>'):
				continue	
			if line.startswith('Num_Banks'):
				num_banks = line.strip().split(':')[1]

			if line.startswith('Bank_Name:'):
				bank_name = line.strip().split(':')[1]	
			
			if line.startswith('Start_Up_Delay:'):
				start_up_delay = line.strip().split(':')[1]
	
			if line.startswith('Len_of_chain:'):
                                chain_len = int(line.strip().split(':')[1])
			
			if line.startswith('No_Clients:'):
                                no_clients = int(line.strip().split(':')[1])
		
			if line.startswith('Server_Life_time:'):
				server_life_time = re.sub(r'[()]','',line.strip().split(':')[1]).split(',')
				
			if line.startswith('reply_wait:'):
                                reply_wait = line.strip().split(':')[1]

			if line.startswith('num_retry:'):
                                num_retry = line.strip().split(':')[1]

			if line.startswith('Random:'):
				temp = line.strip().split(':')[1]
				seed,numReq,probgetbal,probgetdep,probgetwithdraw = re.sub(r'[()]','',temp).strip().split(',')
				request_details = ['random',int(seed),int(numReq),float(probgetbal),float(probgetdep),float(probgetwithdraw)]

			if line.startswith('<Itemized_Req_Start>'):
				request_details = ['itemized']

			match = re.search(r'\[(.*)\]',line.strip())
			
			if match:
				request_details.append(match.group(1))
			
			if line.startswith('<Itemized_Req_End>'):
				continue

			if line.startswith('<Bank-End>'):
				client = Client_Details(bank_name,reply_wait,num_retry,request_details)
				server = Server_Details(start_up_delay,server_life_time)
				bank = Bank_Details(bank_name,chain_len,no_clients,client,server)
				bank_list.append(bank)
	f.close()
	#Do validation for no of banks
	#Create client process for each bank
	for item in bank_list:
		server_list = list(new(Server,num = item.chainlen))
		print('len of servers:',len(server_list))
		print('server_list:',server_list)
		
		for index,server in enumerate(server_list):
			#Server is Head
			if index == 0 and len(server_list) > 1:
				predecessor = None
				successor = server_list[index+1]
			elif index == 0 and len(server_list) == 1:
				predecessor = None
				successor = None
			#Server is Tail
			elif index == len(server_list)-1:
				successor = None
				predecessor = server_list[index-1]
			else:
				predecessor = server_list[index-1]
				successor = server_list[index+1]
			setup(server,[item.bankname,item.server.startupdelay,item.server.serverlifetime,successor,predecessor])
			start(server)			
		clients = new(Client,[item.bankname,item.client.reply_wait,item.client.num_retry,item.client.request_details,server_list[0],server_list[-1]],num = item.no_clients)
		start(clients)
	

